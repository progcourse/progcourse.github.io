<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Lesson 18: React Lifecycle Methods and Hooks (useState, useEffect)</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/stackoverflow-dark.min.css">
        <style>
            code {
                background-color: lightgray;
                color: black;
                padding: 2px 5px;
                margin: 0 5px;
				border: 1px solid gray;
				border-radius: 5px;
            }
			#md{
				display: none;
			}
        </style>
    </head>
    <body class="p-5">
		<a href="#" id="hy" class="btn btn-info">Հայերեն</a>
		<a href="#" id="en" class="btn btn-info" style="display:none">English</a>
		<a href="#" id="ru" class="btn btn-info">Русский</a>
		
		<hr>






		<div id="html_en" class="html">
<h2>Lesson 18: React Lifecycle Methods and Hooks (useState, useEffect)</h2>
<hr>
<h3>Understanding Lifecycle Methods in Class Components</h3>
<h4>Introduction to Lifecycle Methods</h4>
<p>In React, each component goes through a series of &quot;lifecycle&quot; events as it mounts, updates, and eventually unmounts. Lifecycle methods are specialized functions in class components that allow you to hook into these phases to perform specific operations. Understanding these methods is crucial for effective React development, especially when dealing with dynamic applications that require interaction with external systems like APIs or JavaScript frameworks.</p>
<p><strong>Lifecycle Phases:</strong></p>
<ol>
<li><strong>Mounting:</strong> When the component is being created and inserted into the DOM.</li>
<li><strong>Updating:</strong> When the component is being re-rendered as a result of changes to either its props or state.</li>
<li><strong>Unmounting:</strong> When the component is being removed from the DOM.</li>
</ol>
<h4>Key Lifecycle Methods</h4>
<ol>
<li><p><strong>componentDidMount:</strong></p>
<ul>
<li><strong>Purpose:</strong> This method is called immediately after the component is mounted (inserted into the tree). It is useful for initializing the component, such as fetching data, adding event listeners, or interacting with the DOM when the component is first rendered.</li>
<li><strong>Common Uses:</strong> Making AJAX calls to load data from a server.</li>
<li><strong>Example:</strong><pre><code class="language-javascript">componentDidMount() {
    fetch(&#39;https://api.example.com/items&#39;)
        .then(response =&gt; response.json())
        .then(data =&gt; this.setState({ data }));
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>componentDidUpdate:</strong></p>
<ul>
<li><strong>Purpose:</strong> This method is invoked immediately after updating occurs. This method is not called for the initial render.</li>
<li><strong>Use Case:</strong> It is particularly useful for performing checks and executing functions after the component has updated in response to prop or state changes.</li>
<li><strong>Example:</strong><pre><code class="language-javascript">componentDidUpdate(prevProps, prevState) {
    if (this.props.userID !== prevProps.userID) {
        this.fetchData(this.props.userID);
    }
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>componentWillUnmount:</strong></p>
<ul>
<li><strong>Purpose:</strong> This method is invoked immediately before a component is unmounted and destroyed. It is useful for performing any necessary cleanup, such as invalidating timers, canceling network requests, or cleaning up subscriptions that were created in <code>componentDidMount</code>.</li>
<li><strong>Example:</strong><pre><code class="language-javascript">componentWillUnmount() {
    clearInterval(this.interval);
}
</code></pre>
</li>
</ul>
</li>
</ol>
<h4>Practical Exercise: Fetch and Display User Data</h4>
<p><strong>Objective:</strong> Create a class component that interacts with an API to fetch user data and implements cleanup logic.</p>
<p><strong>Steps to Implement:</strong></p>
<ol>
<li><p><strong>Setup a New React Class Component:</strong></p>
<ul>
<li>Create a new class component called <code>UserProfile</code>.</li>
<li>Initialize state to store user data.</li>
</ul>
</li>
<li><p><strong>Implement componentDidMount to Fetch Data:</strong></p>
<ul>
<li>Use <code>componentDidMount</code> to fetch user data from a placeholder API and store it in the state.</li>
</ul>
<pre><code class="language-javascript">class UserProfile extends React.Component {
    constructor(props) {
        super(props);
        this.state = { userData: null };
    }

    componentDidMount() {
        fetch(&#39;https://api.example.com/user/&#39; + this.props.userID)
            .then(response =&gt; response.json())
            .then(data =&gt; this.setState({ userData: data }));
    }

    componentDidUpdate(prevProps) {
        if (this.props.userID !== prevProps.userID) {
            this.fetchData();
        }
    }

    componentWillUnmount() {
        console.log(&#39;Cleaning up...&#39;);
    }

    render() {
        const { userData } = this.state;
        return (
            &lt;div&gt;
                {userData ? (
                    &lt;div&gt;
                        &lt;h1&gt;{userData.name}&lt;/h1&gt;
                        &lt;p&gt;{userData.email}&lt;/p&gt;
                    &lt;/div&gt;
                ) : (
                    &lt;p&gt;Loading...&lt;/p&gt;
                )}
            &lt;/div&gt;
        );
    }
}
</code></pre>
</li>
<li><p><strong>Testing and Debugging:</strong></p>
<ul>
<li>Ensure the component correctly fetches and displays user data upon mounting.</li>
<li>Check that it appropriately cleans up resources or subscriptions when unmounted.</li>
</ul>
</li>
</ol>
<p><strong>Exercise Deliverables:</strong></p>
<ul>
<li>Students should successfully integrate the API fetching in <code>componentDidMount</code> and manage state based on the response.</li>
<li>Implement cleanup logic in <code>componentWillUnmount</code> to handle any potential memory leaks or unnecessary data fetching when the component unmounts.</li>
</ul>
<p>This exercise will help students grasp the importance of lifecycle methods in managing external data and resources in a React application, providing them with practical skills to handle real-world scenarios involving dynamic data.</p>
<h3>Transitioning to Hooks in Functional Components</h3>
<h4>Introduction to Hooks</h4>
<p>Hooks were introduced in React 16.8 as a new addition that allows functional components to manage state and side effects, which were capabilities previously only possible in class components. This significant enhancement not only simplifies the React codebase by reducing the need for classes but also opens up more possibilities for code reuse and better encapsulation.</p>
<p><strong>Advantages of Hooks:</strong></p>
<ul>
<li><strong>Simplicity</strong>: Hooks provide a simpler and more intuitive way to handle stateful logic and lifecycle features in functional components.</li>
<li><strong>Reusability</strong>: Custom hooks can be easily created and shared across components, facilitating reusability of stateful logic without complex patterns like higher-order components or render props.</li>
<li><strong>Cleaner Code</strong>: Hooks lead to flatter component hierarchies and less boilerplate, making the code easier to maintain and understand.</li>
</ul>
<h4>Using the useState Hook</h4>
<p><strong>Basics of useState:</strong></p>
<ul>
<li><p><code>useState</code> is a Hook that lets you add React state to functional components. When you call it, you receive a pair: the current state value and a function that lets you update it.</p>
</li>
<li><p><strong>Syntax</strong>: The standard way to declare state with <code>useState</code> is using array destructuring.</p>
<p><strong>Example</strong>:</p>
<pre><code class="language-javascript">import React, { useState } from &#39;react&#39;;

function Counter() {
    const [count, setCount] = useState(0); // 0 is the initial state

    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
        &lt;/div&gt;
    );
}
</code></pre>
</li>
</ul>
<p><strong>Managing State with useState:</strong></p>
<ul>
<li><p><code>useState</code> is versatile enough to manage any type of state you might need, including strings, numbers, arrays, and objects.</p>
<p><strong>Managing Objects</strong>:</p>
<pre><code class="language-javascript">function UserProfile() {
    const [user, setUser] = useState({ name: &#39;John&#39;, age: 30 });

    const updateAge = () =&gt; setUser({ ...user, age: user.age + 1 });

    return (
        &lt;div&gt;
            &lt;p&gt;Name: {user.name}&lt;/p&gt;
            &lt;p&gt;Age: {user.age}&lt;/p&gt;
            &lt;button onClick={updateAge}&gt;Increment Age&lt;/button&gt;
        &lt;/div&gt;
    );
}
</code></pre>
<p><strong>Managing Arrays</strong>:</p>
<pre><code class="language-javascript">function TodoList() {
    const [todos, setTodos] = useState([&#39;Item 1&#39;, &#39;Item 2&#39;]);

    const addTodo = todo =&gt; setTodos([...todos, todo]);

    return (
        &lt;div&gt;
            {todos.map((todo, index) =&gt; &lt;p key={index}&gt;{todo}&lt;/p&gt;)}
            &lt;button onClick={() =&gt; addTodo(&#39;New Item&#39;)}&gt;Add Item&lt;/button&gt;
        &lt;/div&gt;
    );
}
</code></pre>
</li>
</ul>
<h4>Hands-on Exercise: Refactoring a Class Component</h4>
<p><strong>Objective:</strong> Refactor a class component that fetches user data into a functional component using <code>useState</code>.</p>
<p><strong>Steps:</strong></p>
<ol>
<li><p><strong>Identify the State and Lifecycle Methods in the Class Component</strong>: Review the existing class component to identify how state and lifecycle methods like <code>componentDidMount</code> are being used.</p>
</li>
<li><p><strong>Convert to Functional Component Using useState</strong>:</p>
<pre><code class="language-javascript">import React, { useState, useEffect } from &#39;react&#39;;

function UserProfile({ userID }) {
    const [user, setUser] = useState(null);

    useEffect(() =&gt; {
        fetch(`https://api.example.com/user/${userID}`)
            .then(response =&gt; response.json())
            .then(data =&gt; setUser(data));
    }, [userID]); // Dependency array includes userID to refetch when it changes

    return (
        &lt;div&gt;
            {user ? (
                &lt;div&gt;
                    &lt;h1&gt;{user.name}&lt;/h1&gt;
                    &lt;p&gt;{user.email}&lt;/p&gt;
                &lt;/div&gt;
            ) : (
                &lt;p&gt;Loading...&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}
</code></pre>
</li>
<li><p><strong>Test the Functional Component</strong>: Ensure the refactored component functions as expected, particularly that it correctly fetches and displays user data.</p>
</li>
</ol>
<p>This exercise will solidify students&#39; understanding of how to use <code>useState</code> in real-world scenarios and transition from class components to functional components, leveraging the power and simplicity of Hooks.</p>
<h3>Handling Side Effects with useEffect</h3>
<h4>Understanding useEffect</h4>
<p>The <code>useEffect</code> hook in React is essential for managing side effects in functional components. It is a powerful feature that replaces several lifecycle methods such as <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> from class components. By using <code>useEffect</code>, developers can organize all side effect logic into a single consistent API, making the code easier to maintain and understand.</p>
<p><strong>What are Side Effects?</strong>
Side effects are operations that affect other components, can&#39;t be done during rendering, and include:</p>
<ul>
<li>API calls</li>
<li>Subscriptions</li>
<li>Manually changing the DOM</li>
<li>Timers</li>
</ul>
<h4>Syntax and Usage</h4>
<p><strong>Basic Usage:</strong>
<code>useEffect</code> allows you to perform side effects in your component. It takes two arguments:</p>
<ol>
<li>A function that contains the code for the side effect.</li>
<li>An optional dependency array that dictates when the effect should rerun.</li>
</ol>
<pre><code class="language-javascript">import { useEffect } from &#39;react&#39;;

function ExampleComponent() {
    useEffect(() =&gt; {
        // Code here will run after every render by default
        console.log(&#39;Component rendered or updated&#39;);

        // Optional cleanup mechanism
        return () =&gt; {
            console.log(&#39;Cleanup on component unmount or before next re-render&#39;);
        };
    });
}
</code></pre>
<p><strong>Dependency Array:</strong>
The dependency array is a crucial aspect of <code>useEffect</code> that controls its execution:</p>
<ul>
<li><strong>No Dependency Array</strong>: The effect runs after every render.</li>
<li><strong>Empty Dependency Array (<code>[]</code>)</strong>: The effect runs once after the initial render, mimicking <code>componentDidMount</code>.</li>
<li><strong>Dependencies Listed (<code>[deps]</code>)</strong>: The effect runs after the initial render and every time any value in the dependency array changes.</li>
</ul>
<p><strong>Example of Dependency Array Usage:</strong></p>
<pre><code class="language-javascript">function UserComponent({ userID }) {
    const [user, setUser] = useState(null);

    useEffect(() =&gt; {
        fetch(`https://api.example.com/users/${userID}`)
            .then(response =&gt; response.json())
            .then(userData =&gt; setUser(userData));

        return () =&gt; {
            // Cleanup code here
        };
    }, [userID]); // Effect re-runs only if userID changes
}
</code></pre>
<h4>Complex Effects and Cleanup</h4>
<p><strong>Returning a Cleanup Function:</strong>
<code>useEffect</code> may optionally return a function that cleans up after the effect. This is useful for:</p>
<ul>
<li>Unsubscribing from subscriptions to prevent memory leaks.</li>
<li>Clearing timers or canceling ongoing network requests.</li>
</ul>
<p><strong>Example with Cleanup:</strong></p>
<pre><code class="language-javascript">function TimerComponent() {
    useEffect(() =&gt; {
        const timerID = setInterval(() =&gt; {
            console.log(&#39;Timer tick&#39;);
        }, 1000);

        return () =&gt; {
            clearInterval(timerID);
        };
    }, []); // Empty dependency array means this runs only on mount
}
</code></pre>
<h4>Practical Exercises</h4>
<p><strong>Exercise 1: Data Fetching Effect</strong></p>
<ul>
<li>Implement a component that fetches user data from an API when it mounts and updates the data whenever a given userID changes.</li>
</ul>
<p><strong>Exercise 2: Interval Timer Effect</strong></p>
<ul>
<li>Create a <code>Clock</code> component that uses an interval to update the current time every second.</li>
</ul>
<p><strong>Implementation of Clock Component:</strong></p>
<pre><code class="language-javascript">function Clock() {
    const [currentTime, setCurrentTime] = useState(new Date());

    useEffect(() =&gt; {
        const timerId = setInterval(() =&gt; {
            setCurrentTime(new Date());
        }, 1000);

        return () =&gt; {
            clearInterval(timerId);
        };
    }, []); // Empty array ensures this runs only once

    return (
        &lt;div&gt;
            &lt;h1&gt;Current Time&lt;/h1&gt;
            &lt;p&gt;{currentTime.toLocaleTimeString()}&lt;/p&gt;
        &lt;/div&gt;
    );
}
</code></pre>
<p>These exercises are designed to provide hands-on experience with <code>useEffect</code>, demonstrating how it can be used to manage side effects efficiently in functional components. The exercises highlight both basic and advanced usage, including the critical role of the cleanup function in avoiding resource leaks.</p>
<h3>Wrap-up and Q&amp;A</h3>
<p>As we conclude today&#39;s detailed exploration of React&#39;s lifecycle methods in class components and the revolutionary Hooks in functional components, let&#39;s recap the key concepts and prepare for a Q&amp;A session to clear up any remaining uncertainties.</p>
<h4>Review and Summary</h4>
<p><strong>Lifecycle Methods in Class Components:</strong></p>
<ul>
<li><strong>Overview:</strong> We discussed the critical lifecycle methods—<code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code>. These methods provide hooks into specific times in a component’s life: when it’s being added to the DOM, undergoing updates, and being removed from the DOM, respectively.</li>
<li><strong>Applications:</strong> <ul>
<li><code>componentDidMount</code> is ideal for setting up subscriptions, fetching data, and other setup tasks that should only run once after the initial render.</li>
<li><code>componentDidUpdate</code> allows for responding to changes in props or state, making it useful for adjusting to updated data or re-fetching data when certain conditions change.</li>
<li><code>componentWillUnmount</code> is crucial for cleanup activities like invalidating timers, canceling network requests, or cleaning up subscriptions to prevent memory leaks.</li>
</ul>
</li>
</ul>
<p><strong>Introduction to Hooks:</strong></p>
<ul>
<li><strong>Transformation in Functional Components:</strong> Hooks represent a significant advancement in React, providing functional components the capabilities that were once only possible in class components.</li>
<li><strong>useState and useEffect:</strong><ul>
<li><code>useState</code> offers a way to add stateful logic to functional components, allowing them to maintain internal state over time.</li>
<li><code>useEffect</code> serves as a unified way to handle side effects in functional components, effectively replacing multiple lifecycle methods and offering more precise control over when side effects run and how they clean up.</li>
</ul>
</li>
</ul>
<p><strong>Practical Applications and Exercises:</strong></p>
<ul>
<li>We&#39;ve applied these concepts through practical exercises, such as transforming a class component that fetches data into a functional component using <code>useState</code> and <code>useEffect</code>. These exercises not only reinforced the material but also demonstrated the practical benefits of Hooks, such as reduced boilerplate and improved code organization.</li>
</ul>
<h4>Q&amp;A Session</h4>
<p>Now, let&#39;s transition into our Q&amp;A session. This is an excellent opportunity for you to ask questions about any aspect of today&#39;s material. Whether you need clarification on the details of lifecycle methods, the mechanics of specific Hooks, or advice on how to apply these concepts to real-world problems, feel free to bring your queries forward.</p>
<p><strong>Possible Topics for Discussion:</strong></p>
<ul>
<li><strong>Differences in Use Cases:</strong> When might you choose class components over functional components, especially considering Hooks?</li>
<li><strong>Optimizing Performance with Hooks:</strong> How can you prevent unnecessary renders when using <code>useState</code> and <code>useEffect</code>?</li>
<li><strong>Advanced Hook Patterns:</strong> Are there more complex scenarios where combining multiple Hooks would be beneficial?</li>
</ul>
<p>Feel free to share your experiences, any specific challenges you&#39;ve faced, or how you envision applying what you&#39;ve learned in your projects. This discussion can help solidify your understanding and inspire new ideas for leveraging React&#39;s powerful features in your development work.</p>

		</div>






		<div id="html_hy" class="html" style="display:none">
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Դաս 18. React Lifecycle Methods and Hooks (useState, useEffect)</font></font></h2>
<hr>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Հասկանալով կյանքի ցիկլի մեթոդները դասի բաղադրիչներում</font></font></h3>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կյանքի ցիկլի մեթոդների ներածություն</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React-ում յուրաքանչյուր բաղադրիչ անցնում է մի շարք «կյանքի ցիկլի» իրադարձությունների, երբ այն տեղադրվում է, թարմացվում և, ի վերջո, ապամոնտաժվում է: Կյանքի ցիկլի մեթոդները մասնագիտացված գործառույթներ են դասի բաղադրիչներում, որոնք թույլ են տալիս միանալ այս փուլերին՝ կոնկրետ գործողություններ կատարելու համար: Այս մեթոդների ըմբռնումը կարևոր է արդյունավետ React-ի մշակման համար, հատկապես երբ գործ ունենք դինամիկ հավելվածների հետ, որոնք պահանջում են փոխազդեցություն արտաքին համակարգերի հետ, ինչպիսիք են API-ները կամ JavaScript շրջանակները:</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կյանքի ցիկլի փուլերը.</font></font></strong></p>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Մոնտաժ.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Երբ բաղադրիչը ստեղծվում և տեղադրվում է DOM-ում:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Թարմացում.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Երբ բաղադրիչը վերաարտադրվում է կամ իր հենակետերի կամ վիճակի փոփոխությունների արդյունքում:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ապամոնտաժում.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Երբ բաղադրիչը հեռացվում է DOM-ից:</font></font></li>
</ol>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Հիմնական կյանքի ցիկլի մեթոդներ</font></font></h4>
<ol>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentDidMount:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Նպատակը.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Այս մեթոդը կոչվում է բաղադրիչը տեղադրվելուց (ծառի մեջ մտցնելուց) անմիջապես հետո: Այն օգտակար է բաղադրիչը սկզբնավորելու համար, օրինակ՝ տվյալներ բեռնելու, իրադարձությունների ունկնդիրների ավելացման կամ DOM-ի հետ փոխազդեցության համար, երբ բաղադրիչն առաջին անգամ ներկայացվում է:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ընդհանուր կիրառումներ.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AJAX զանգեր կատարել՝ սերվերից տվյալներ բեռնելու համար:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օրինակ:</font></font></strong><pre><code class="language-javascript">componentDidMount() {<font></font>
    fetch('https://api.example.com/items')<font></font>
        .then(response =&gt; response.json())<font></font>
        .then(data =&gt; this.setState({ data }));<font></font>
}<font></font>
</code></pre>
</li>
</ul>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">componentDidUpdate:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Նպատակը.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Այս մեթոդը գործարկվում է թարմացումից անմիջապես հետո: Այս մեթոդը չի կանչվում սկզբնական ցուցադրման համար:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օգտագործման դեպք.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> այն հատկապես օգտակար է ստուգումներ կատարելու և գործառույթներ կատարելու համար, երբ բաղադրիչը թարմացվել է՝ ի պատասխան հենակետի կամ վիճակի փոփոխությունների:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օրինակ:</font></font></strong><pre><code class="language-javascript">componentDidUpdate(prevProps, prevState) {<font></font>
    if (this.props.userID !== prevProps.userID) {<font></font>
        this.fetchData(this.props.userID);<font></font>
    }<font></font>
}<font></font>
</code></pre>
</li>
</ul>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">բաղադրիչըՄիանամոնտաժվի.</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Նպատակը.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Այս մեթոդը գործարկվում է անմիջապես բաղադրիչի ապամոնտաժումից և ոչնչացումից առաջ: Այն օգտակար է ցանկացած անհրաժեշտ մաքրում կատարելու համար, օրինակ՝ ժամաչափերի անվավեր ճանաչման, ցանցի հարցումների չեղարկման կամ բաժանորդագրությունների մաքրման համար, որոնք ստեղծվել են </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օրինակ:</font></font></strong><pre><code class="language-javascript">componentWillUnmount() {<font></font>
    clearInterval(this.interval);<font></font>
}<font></font>
</code></pre>
</li>
</ul>
</li>
</ol>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Գործնական վարժություն. Ստացեք և ցուցադրեք օգտվողի տվյալները</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Նպատակը.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ստեղծեք դասի բաղադրիչ, որը փոխազդում է API-ի հետ՝ օգտատիրոջ տվյալները բերելու և մաքրման տրամաբանություն իրականացնելու համար:</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Իրականացման քայլեր.</font></font></strong></p>
<ol>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ստեղծեք նոր React դասի բաղադրիչ.</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ստեղծեք նոր դասի բաղադրիչ, որը կոչվում է </font></font><code>UserProfile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Նախաձեռնել վիճակը՝ օգտատիրոջ տվյալները պահելու համար:</font></font></li>
</ul>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Իրականացնել componentDidMount՝ տվյալներ ստանալու համար.</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օգտագործեք </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">օգտատիրոջ տվյալները տեղապահի API-ից վերցնելու և այն վիճակում պահելու համար:</font></font></li>
</ul>
<pre><code class="language-javascript">class UserProfile extends React.Component {<font></font>
    constructor(props) {<font></font>
        super(props);<font></font>
        this.state = { userData: null };<font></font>
    }<font></font>
<font></font>
    componentDidMount() {<font></font>
        fetch('https://api.example.com/user/' + this.props.userID)<font></font>
            .then(response =&gt; response.json())<font></font>
            .then(data =&gt; this.setState({ userData: data }));<font></font>
    }<font></font>
<font></font>
    componentDidUpdate(prevProps) {<font></font>
        if (this.props.userID !== prevProps.userID) {<font></font>
            this.fetchData();<font></font>
        }<font></font>
    }<font></font>
<font></font>
    componentWillUnmount() {<font></font>
        console.log('Cleaning up...');<font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        const { userData } = this.state;<font></font>
        return (<font></font>
            &lt;div&gt;<font></font>
                {userData ? (<font></font>
                    &lt;div&gt;<font></font>
                        &lt;h1&gt;{userData.name}&lt;/h1&gt;<font></font>
                        &lt;p&gt;{userData.email}&lt;/p&gt;<font></font>
                    &lt;/div&gt;<font></font>
                ) : (<font></font>
                    &lt;p&gt;Loading...&lt;/p&gt;<font></font>
                )}<font></font>
            &lt;/div&gt;<font></font>
        );<font></font>
    }<font></font>
}<font></font>
</code></pre>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Փորձարկում և վրիպազերծում.</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Համոզվեք, որ բաղադրիչը ճիշտ է վերցնում և ցուցադրում օգտվողի տվյալները մոնտաժման ժամանակ:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ստուգեք, որ այն պատշաճ կերպով մաքրում է ռեսուրսները կամ բաժանորդագրությունները, երբ ապամոնտաժված է:</font></font></li>
</ul>
</li>
</ol>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Զորավարժությունների առաքում.</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ուսանողները պետք է հաջողությամբ ինտեգրեն API-ի բեռնումը </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">և կառավարեն վիճակը՝ հիմնվելով պատասխանի վրա:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կիրառեք մաքրման տրամաբանություն՝ </font></font><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">հիշողության հնարավոր արտահոսքի կամ անհարկի տվյալների առբերման համար, երբ բաղադրիչն ապամոնտաժվում է:</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Այս վարժությունը կօգնի ուսանողներին հասկանալ կյանքի ցիկլի մեթոդների կարևորությունը React հավելվածում արտաքին տվյալների և ռեսուրսների կառավարման մեջ՝ ապահովելով նրանց գործնական հմտություններ՝ դինամիկ տվյալների հետ կապված իրական աշխարհի սցենարները վարելու համար:</font></font></p>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Անցում դեպի Կեռիկներ ֆունկցիոնալ բաղադրիչներում</font></font></h3>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կեռիկներ ներածություն</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hooks-ը ներկայացվել է React 16.8-ում որպես նոր հավելում, որը թույլ է տալիս ֆունկցիոնալ բաղադրիչներին կառավարել վիճակը և կողմնակի ազդեցությունները, որոնք նախկինում հնարավոր էին միայն դասի բաղադրիչներում: Այս նշանակալի բարելավումը ոչ միայն պարզեցնում է React կոդերի բազան՝ նվազեցնելով դասերի կարիքը, այլև ավելի շատ հնարավորություններ է բացում կոդի վերօգտագործման և ավելի լավ ընդգրկման համար:</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կեռիկների առավելությունները.</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Պարզություն</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Կեռիկներն ապահովում են ավելի պարզ և ինտուիտիվ միջոց՝ ֆունկցիոնալ բաղադրիչներում վիճակագրական տրամաբանության և կյանքի ցիկլի առանձնահատկությունները կարգավորելու համար:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կրկնակի օգտագործման հնարավորություն</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Պատվերով կեռիկները կարող են հեշտությամբ ստեղծվել և համօգտագործվել բաղադրիչների միջև՝ հեշտացնելով պետական &ZeroWidthSpace;&ZeroWidthSpace;տրամաբանության կրկնակի օգտագործումը՝ առանց բարդ օրինաչափությունների, ինչպիսիք են ավելի բարձր կարգի բաղադրիչները կամ ռենդերային հենարանները:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Մաքուր ծածկագիր</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Կեռիկներն ավելի հարթ են դարձնում բաղադրիչների հիերարխիան և ավելի քիչ կաթսայատներ, ինչը հեշտացնում է ծածկագիրը պահպանելը և հասկանալը:</font></font></li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օգտագործելով useState Hook-ը</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օգտագործման հիմունքները:</font></font></strong></p>
<ul>
<li><p><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կեռիկ է, որը թույլ է տալիս ավելացնել React վիճակ ֆունկցիոնալ բաղադրիչներին: Երբ զանգում եք այն, դուք ստանում եք զույգ՝ ընթացիկ վիճակի արժեքը և ֆունկցիա, որը թույլ է տալիս թարմացնել այն:</font></font></p>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Շարահյուսություն</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . վիճակի հայտարարման ստանդարտ եղանակը </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">զանգվածների ապակառուցումն է:</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օրինակ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></p>
<pre><code class="language-javascript">import React, { useState } from 'react';<font></font>
<font></font>
function Counter() {<font></font>
    const [count, setCount] = useState(0); // 0 is the initial state<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            &lt;p&gt;Count: {count}&lt;/p&gt;<font></font>
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
</li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կառավարող պետությունը useState-ով.</font></font></strong></p>
<ul>
<li><p><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">բավականաչափ բազմակողմանի է կառավարելու ձեզ ցանկացած տեսակի վիճակ, ներառյալ տողերը, թվերը, զանգվածները և օբյեկտները:</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օբյեկտների կառավարում</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<pre><code class="language-javascript">function UserProfile() {<font></font>
    const [user, setUser] = useState({ name: 'John', age: 30 });<font></font>
<font></font>
    const updateAge = () =&gt; setUser({ ...user, age: user.age + 1 });<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            &lt;p&gt;Name: {user.name}&lt;/p&gt;<font></font>
            &lt;p&gt;Age: {user.age}&lt;/p&gt;<font></font>
            &lt;button onClick={updateAge}&gt;Increment Age&lt;/button&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Զանգվածների կառավարում</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></p>
<pre><code class="language-javascript">function TodoList() {<font></font>
    const [todos, setTodos] = useState(['Item 1', 'Item 2']);<font></font>
<font></font>
    const addTodo = todo =&gt; setTodos([...todos, todo]);<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            {todos.map((todo, index) =&gt; &lt;p key={index}&gt;{todo}&lt;/p&gt;)}<font></font>
            &lt;button onClick={() =&gt; addTodo('New Item')}&gt;Add Item&lt;/button&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
</li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Գործնական վարժություն. դասի բաղադրիչի վերամշակում</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Նպատակը.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Refactor դասի բաղադրիչ, որը բեռնում է օգտվողի տվյալները ֆունկցիոնալ բաղադրիչի մեջ՝ օգտագործելով </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Քայլեր:</font></font></strong></p>
<ol>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Որոշեք դասի բաղադրիչի վիճակը և կյանքի ցիկլի մեթոդները</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Վերանայեք առկա դասի բաղադրիչը՝ պարզելու, թե ինչպես </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">են օգտագործվում վիճակի և կյանքի ցիկլի նման մեթոդները:</font></font></p>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Փոխարկել ֆունկցիոնալ բաղադրիչի, օգտագործելով useState</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';<font></font>
<font></font>
function UserProfile({ userID }) {<font></font>
    const [user, setUser] = useState(null);<font></font>
<font></font>
    useEffect(() =&gt; {<font></font>
        fetch(`https://api.example.com/user/${userID}`)<font></font>
            .then(response =&gt; response.json())<font></font>
            .then(data =&gt; setUser(data));<font></font>
    }, [userID]); // Dependency array includes userID to refetch when it changes<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            {user ? (<font></font>
                &lt;div&gt;<font></font>
                    &lt;h1&gt;{user.name}&lt;/h1&gt;<font></font>
                    &lt;p&gt;{user.email}&lt;/p&gt;<font></font>
                &lt;/div&gt;<font></font>
            ) : (<font></font>
                &lt;p&gt;Loading...&lt;/p&gt;<font></font>
            )}<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ստուգեք ֆունկցիոնալ բաղադրիչը</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Համոզվեք, որ վերամշակված բաղադրիչը գործում է այնպես, ինչպես սպասվում է, մասնավորապես, որ այն ճիշտ է վերցնում և ցուցադրում օգտվողի տվյալները:</font></font></p>
</li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Այս վարժությունը կամրապնդի ուսանողների ըմբռնումը, թե ինչպես օգտագործել </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">իրական աշխարհի սցենարներում և դասի բաղադրիչներից ֆունկցիոնալ բաղադրիչներին անցնել՝ օգտագործելով Hooks-ի ուժն ու պարզությունը:</font></font></p>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կողմնակի էֆեկտների կառավարում useEffect-ով</font></font></h3>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Հասկանալով useEffect-ը</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React-ի կեռիկը </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">կարևոր է ֆունկցիոնալ բաղադրիչների կողմնակի ազդեցությունները կառավարելու համար: Այն հզոր հատկանիշ է, որը փոխարինում է կյանքի ցիկլի մի քանի մեթոդներ, ինչպիսիք են </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, և </font></font><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">դասի բաղադրիչներից: Օգտագործելով </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, մշակողները կարող են կազմակերպել կողմնակի ազդեցությունների ողջ տրամաբանությունը մեկ հետևողական API-ի մեջ՝ դարձնելով ծածկագիրը ավելի հեշտ պահելը և հասկանալը:</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Որոնք են կողմնակի ազդեցությունները:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Կողմնակի էֆեկտները գործողություններ են, որոնք ազդում են այլ բաղադրիչների վրա, չեն կարող կատարվել արտապատկերման ընթացքում և ներառում են.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API զանգեր</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Բաժանորդագրություններ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ձեռքով փոխելով DOM-ը</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ժամաչափեր</font></font></li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Շարահյուսություն և օգտագործում</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Հիմնական օգտագործումը.</font></font></strong>
<code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> թույլ է տալիս կողմնակի ազդեցություններ ունենալ ձեր բաղադրիչում: Այն պահանջում է երկու փաստարկ.</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Գործառույթ, որը պարունակում է կողմնակի ազդեցության կոդը:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ընտրովի կախվածության զանգված, որը թելադրում է, թե երբ է էֆեկտը պետք է կրկնվի:</font></font></li>
</ol>
<pre><code class="language-javascript">import { useEffect } from 'react';<font></font>
<font></font>
function ExampleComponent() {<font></font>
    useEffect(() =&gt; {<font></font>
        // Code here will run after every render by default<font></font>
        console.log('Component rendered or updated');<font></font>
<font></font>
        // Optional cleanup mechanism<font></font>
        return () =&gt; {<font></font>
            console.log('Cleanup on component unmount or before next re-render');<font></font>
        };<font></font>
    });<font></font>
}<font></font>
</code></pre>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կախվածության զանգված.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Կախվածության զանգվածը կարևոր ասպեկտ է, </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">որը վերահսկում է դրա կատարումը.</font></font></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կախվածության զանգված չկա</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . էֆեկտը գործում է յուրաքանչյուր ցուցադրումից հետո:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Դատարկ կախվածության զանգված</font></font><code>[]</code><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><strong><font style="vertical-align: inherit;">)</font></strong><font style="vertical-align: inherit;"> .</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ցուցակված կախվածություններ ( </font></font><code>[deps]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Էֆեկտը գործում է սկզբնական ցուցադրումից հետո և ամեն անգամ, երբ կախվածության զանգվածի որևէ արժեք փոխվում է:</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կախվածության զանգվածի օգտագործման օրինակ.</font></font></strong></p>
<pre><code class="language-javascript">function UserComponent({ userID }) {<font></font>
    const [user, setUser] = useState(null);<font></font>
<font></font>
    useEffect(() =&gt; {<font></font>
        fetch(`https://api.example.com/users/${userID}`)<font></font>
            .then(response =&gt; response.json())<font></font>
            .then(userData =&gt; setUser(userData));<font></font>
<font></font>
        return () =&gt; {<font></font>
            // Cleanup code here<font></font>
        };<font></font>
    }, [userID]); // Effect re-runs only if userID changes<font></font>
}<font></font>
</code></pre>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Համալիր էֆեկտներ և մաքրում</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Մաքրման գործառույթի վերադարձ.</font></font></strong>
<code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> կարող է կամայականորեն վերադարձնել գործառույթ, որը մաքրվում է էֆեկտից հետո: Սա օգտակար է հետևյալի համար.</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Բաժանորդագրություններից դուրս գալ՝ հիշողության արտահոսքը կանխելու համար:</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ժամաչափերի մաքրում կամ ցանցի ընթացիկ հարցումների չեղարկում:</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Մաքրման օրինակ.</font></font></strong></p>
<pre><code class="language-javascript">function TimerComponent() {<font></font>
    useEffect(() =&gt; {<font></font>
        const timerID = setInterval(() =&gt; {<font></font>
            console.log('Timer tick');<font></font>
        }, 1000);<font></font>
<font></font>
        return () =&gt; {<font></font>
            clearInterval(timerID);<font></font>
        };<font></font>
    }, []); // Empty dependency array means this runs only on mount<font></font>
}<font></font>
</code></pre>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Գործնական վարժություններ</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Վարժություն 1. Տվյալների առբերման էֆեկտ</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կիրառեք բաղադրիչ, որը վերցնում է օգտվողի տվյալները API-ից, երբ այն տեղադրվում և թարմացնում է տվյալները, երբ տվյալ օգտվողի ID-ն փոխվում է:</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Վարժություն 2. Ինտերվալ ժմչփի էֆեկտ</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ստեղծեք </font></font><code>Clock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">բաղադրիչ, որն օգտագործում է ընդմիջում՝ ընթացիկ ժամանակը ամեն վայրկյան թարմացնելու համար:</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ժամացույցի բաղադրիչի իրականացում.</font></font></strong></p>
<pre><code class="language-javascript">function Clock() {<font></font>
    const [currentTime, setCurrentTime] = useState(new Date());<font></font>
<font></font>
    useEffect(() =&gt; {<font></font>
        const timerId = setInterval(() =&gt; {<font></font>
            setCurrentTime(new Date());<font></font>
        }, 1000);<font></font>
<font></font>
        return () =&gt; {<font></font>
            clearInterval(timerId);<font></font>
        };<font></font>
    }, []); // Empty array ensures this runs only once<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            &lt;h1&gt;Current Time&lt;/h1&gt;<font></font>
            &lt;p&gt;{currentTime.toLocaleTimeString()}&lt;/p&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Այս վարժությունները նախատեսված են գործնական փորձ ապահովելու համար՝ </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ցույց տալով, թե ինչպես կարող է այն օգտագործվել ֆունկցիոնալ բաղադրիչներում արդյունավետ կերպով կառավարելու կողմնակի ազդեցությունները: Զորավարժությունները ընդգծում են ինչպես հիմնական, այնպես էլ առաջադեմ օգտագործումը, ներառյալ մաքրման գործառույթի կարևոր դերը ռեսուրսների արտահոսքից խուսափելու համար:</font></font></p>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ամփոփում և հարց ու պատասխան</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Երբ մենք ավարտում ենք React-ի կյանքի ցիկլի մեթոդների այսօրվա մանրամասն ուսումնասիրությունը դասի բաղադրիչներում և հեղափոխական Hooks-ը ֆունկցիոնալ բաղադրիչներում, եկեք ամփոփենք հիմնական հասկացությունները և պատրաստվենք Q&amp;A նիստին, որպեսզի բացահայտենք մնացած անորոշությունները:</font></font></p>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Վերանայում և ամփոփում</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կյանքի ցիկլի մեթոդներ դասի բաղադրիչներում.</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Համառոտ նկարագիր.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Մենք քննարկեցինք կյանքի ցիկլի կրիտիկական մեթոդները </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">՝ , </font></font><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, և </font></font><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Այս մեթոդներն ապահովում են կեռիկներ բաղադրիչի կյանքի որոշակի ժամանակահատվածներում. երբ այն ավելացվում է DOM-ին, ենթարկվում թարմացումների և համապատասխանաբար հեռացվում է DOM-ից:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ծրագրեր:</font></font></strong> <ul>
<li><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">իդեալական է բաժանորդագրություններ կարգավորելու, տվյալների առբերման և տեղադրման այլ առաջադրանքներ, որոնք պետք է գործարկվեն միայն մեկ անգամ սկզբնական ցուցադրումից հետո:</font></font></li>
<li><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">թույլ է տալիս արձագանքել հենակետերի կամ վիճակի փոփոխություններին՝ այն օգտակար դարձնելով թարմացված տվյալներին հարմարեցնելու կամ որոշակի պայմանների փոփոխման դեպքում տվյալներ նորից վերցնելու համար:</font></font></li>
<li><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Շատ կարևոր է մաքրման գործողությունների համար, ինչպիսիք են ժամաչափերի անվավերությունը, ցանցի հարցումների չեղարկումը կամ բաժանորդագրությունների մաքրումը` հիշողության արտահոսքը կանխելու համար:</font></font></li>
</ul>
</li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կեռիկների ներածություն.</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Փոխակերպում ֆունկցիոնալ բաղադրիչներում.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hooks-ը զգալի առաջընթաց է ներկայացնում React-ում՝ ապահովելով ֆունկցիոնալ բաղադրիչների այնպիսի հնարավորություններ, որոնք ժամանակին հնարավոր էին միայն դասի բաղադրիչներում:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useState և useEffect:</font></font></strong><ul>
<li><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">առաջարկում է ֆունկցիոնալ բաղադրիչներին պետական &ZeroWidthSpace;&ZeroWidthSpace;տրամաբանություն ավելացնելու միջոց՝ թույլ տալով նրանց պահպանել ներքին վիճակը ժամանակի ընթացքում:</font></font></li>
<li><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ծառայում է որպես ֆունկցիոնալ բաղադրիչներում կողմնակի ազդեցությունները կարգավորելու միասնական միջոց՝ արդյունավետորեն փոխարինելով կյանքի ցիկլի մի քանի մեթոդները և ավելի ճշգրիտ վերահսկելով, թե երբ են կողմնակի ազդեցությունները գործարկվում և ինչպես են դրանք մաքրվում:</font></font></li>
</ul>
</li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Գործնական կիրառություններ և վարժություններ.</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Մենք կիրառել ենք այս հասկացությունները գործնական վարժությունների միջոցով, ինչպիսիք են դասի բաղադրիչի փոխակերպումը, որը տվյալները բեռնում է ֆունկցիոնալ բաղադրիչի, օգտագործելով </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">և </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Այս վարժությունները ոչ միայն ամրապնդեցին նյութը, այլև ցույց տվեցին Հուքսի գործնական առավելությունները, ինչպիսիք են կաթսայի կրճատումը և ծածկագրի բարելավված կազմակերպումը:</font></font></li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Հարց ու պատասխան նիստ</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Այժմ, եկեք անցնենք մեր հարցուպատասխանի նիստին: Սա հիանալի հնարավորություն է ձեզ համար հարցեր տալու այսօրվա նյութի ցանկացած ասպեկտի վերաբերյալ: Անկախ նրանից, թե ձեզ անհրաժեշտ են պարզաբանումներ կյանքի ցիկլի մեթոդների մանրամասների, կոնկրետ Հուքսի մեխանիզմի կամ խորհրդատվության վերաբերյալ, թե ինչպես կիրառել այս հասկացությունները իրական աշխարհի խնդիրների վրա, ազատ զգալ առաջ քաշեք ձեր հարցումները:</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Քննարկման հնարավոր թեմաներ.</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Օգտագործման դեպքերի տարբերություններ.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ե՞րբ կարող եք ընտրել դասի բաղադրիչները ֆունկցիոնալ բաղադրիչների փոխարեն, հատկապես հաշվի առնելով Hooks-ը:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Կեռիկների միջոցով կատարողականի օպտիմիզացում.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ինչպե՞ս կարող եք կանխել անհարկի արտապատկերումները, երբ օգտագործում եք </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">և </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ընդլայնված Կեռիկներ.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Կա՞ն ավելի բարդ սցենարներ, որտեղ մի քանի Կեռիկներ համատեղելը ձեռնտու կլինի:</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ազատորեն կիսվեք ձեր փորձով, ձեր առջև ծառացած որևէ կոնկրետ մարտահրավերով կամ ինչպես եք պատկերացնում ձեր սովորածը կիրառել ձեր նախագծերում: Այս քննարկումը կարող է օգնել ամրապնդել ձեր ըմբռնումը և ներշնչել նոր գաղափարներ՝ ձեր մշակման աշխատանքում React-ի հզոր հատկությունները օգտագործելու համար:</font></font></p>
		</div>






		<div id="html_ru" class="html" style="display:none">
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Урок 18: Методы жизненного цикла React и хуки (useState, useEffect)</font></font></h2>
<hr>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Понимание методов жизненного цикла в компонентах класса</font></font></h3>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Введение в методы жизненного цикла</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">В React каждый компонент проходит серию событий «жизненного цикла» при монтировании, обновлении и, в конечном итоге, отключении. Методы жизненного цикла — это специализированные функции в компонентах класса, которые позволяют вам подключаться к этим этапам для выполнения определенных операций. Понимание этих методов имеет решающее значение для эффективной разработки React, особенно при работе с динамическими приложениями, требующими взаимодействия с внешними системами, такими как API или платформы JavaScript.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Фазы жизненного цикла:</font></font></strong></p>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Монтаж:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> когда компонент создается и вставляется в DOM.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Обновление:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> когда компонент повторно визуализируется в результате изменений его свойств или состояния.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Размонтирование:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> когда компонент удаляется из DOM.</font></font></li>
</ol>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ключевые методы жизненного цикла</font></font></h4>
<ol>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">компонентДидМаунт:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Назначение:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Этот метод вызывается сразу после монтирования компонента (вставки в дерево). Это полезно для инициализации компонента, например для получения данных, добавления прослушивателей событий или взаимодействия с DOM при первой визуализации компонента.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Обычное использование:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> выполнение вызовов AJAX для загрузки данных с сервера.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Пример:</font></font></strong><pre><code class="language-javascript">componentDidMount() {<font></font>
    fetch('https://api.example.com/items')<font></font>
        .then(response =&gt; response.json())<font></font>
        .then(data =&gt; this.setState({ data }));<font></font>
}<font></font>
</code></pre>
</li>
</ul>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">компонентДидОбновление:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Назначение:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> этот метод вызывается сразу после обновления. Этот метод не вызывается для первоначального рендеринга.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Вариант использования:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> это особенно полезно для выполнения проверок и выполнения функций после обновления компонента в ответ на изменения свойств или состояния.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Пример:</font></font></strong><pre><code class="language-javascript">componentDidUpdate(prevProps, prevState) {<font></font>
    if (this.props.userID !== prevProps.userID) {<font></font>
        this.fetchData(this.props.userID);<font></font>
    }<font></font>
}<font></font>
</code></pre>
</li>
</ul>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">компонентWillUnmount:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Назначение:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> этот метод вызывается непосредственно перед отмонтированием и уничтожением компонента. Это полезно для выполнения любой необходимой очистки, такой как аннулирование таймеров, отмена сетевых запросов или очистка подписок, созданных в </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Пример:</font></font></strong><pre><code class="language-javascript">componentWillUnmount() {<font></font>
    clearInterval(this.interval);<font></font>
}<font></font>
</code></pre>
</li>
</ul>
</li>
</ol>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Практическое упражнение: получение и отображение пользовательских данных</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Цель:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> создать компонент класса, который взаимодействует с API для получения пользовательских данных и реализует логику очистки.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Шаги по реализации:</font></font></strong></p>
<ol>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Настройте новый компонент класса React:</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Создайте новый компонент класса с именем </font></font><code>UserProfile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Инициализировать состояние для хранения пользовательских данных.</font></font></li>
</ul>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Реализуйте компонентDidMount для получения данных:</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Используйте </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">для получения пользовательских данных из API-заполнителя и сохранения их в состоянии.</font></font></li>
</ul>
<pre><code class="language-javascript">class UserProfile extends React.Component {<font></font>
    constructor(props) {<font></font>
        super(props);<font></font>
        this.state = { userData: null };<font></font>
    }<font></font>
<font></font>
    componentDidMount() {<font></font>
        fetch('https://api.example.com/user/' + this.props.userID)<font></font>
            .then(response =&gt; response.json())<font></font>
            .then(data =&gt; this.setState({ userData: data }));<font></font>
    }<font></font>
<font></font>
    componentDidUpdate(prevProps) {<font></font>
        if (this.props.userID !== prevProps.userID) {<font></font>
            this.fetchData();<font></font>
        }<font></font>
    }<font></font>
<font></font>
    componentWillUnmount() {<font></font>
        console.log('Cleaning up...');<font></font>
    }<font></font>
<font></font>
    render() {<font></font>
        const { userData } = this.state;<font></font>
        return (<font></font>
            &lt;div&gt;<font></font>
                {userData ? (<font></font>
                    &lt;div&gt;<font></font>
                        &lt;h1&gt;{userData.name}&lt;/h1&gt;<font></font>
                        &lt;p&gt;{userData.email}&lt;/p&gt;<font></font>
                    &lt;/div&gt;<font></font>
                ) : (<font></font>
                    &lt;p&gt;Loading...&lt;/p&gt;<font></font>
                )}<font></font>
            &lt;/div&gt;<font></font>
        );<font></font>
    }<font></font>
}<font></font>
</code></pre>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Тестирование и отладка:</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Убедитесь, что компонент правильно извлекает и отображает пользовательские данные после установки.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Убедитесь, что он надлежащим образом очищает ресурсы или подписки при размонтировании.</font></font></li>
</ul>
</li>
</ol>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Результаты упражнения:</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Студенты должны успешно интегрировать получение API </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">и управлять состоянием на основе ответа.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Внедрите логику очистки для </font></font><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">обработки любых потенциальных утечек памяти или ненужной выборки данных при размонтировании компонента.</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Это упражнение поможет студентам понять важность методов жизненного цикла при управлении внешними данными и ресурсами в приложении React, предоставив им практические навыки для обработки реальных сценариев, включающих динамические данные.</font></font></p>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Переход на хуки в функциональных компонентах</font></font></h3>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Введение в хуки</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Хуки были представлены в React 16.8 как новое дополнение, которое позволяет функциональным компонентам управлять состоянием и побочными эффектами, которые раньше были возможны только в компонентах классов. Это значительное улучшение не только упрощает кодовую базу React за счет уменьшения необходимости в классах, но также открывает больше возможностей для повторного использования кода и лучшей инкапсуляции.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Преимущества крючков:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Простота</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : хуки обеспечивают более простой и интуитивно понятный способ обработки логики с отслеживанием состояния и функций жизненного цикла в функциональных компонентах.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Возможность повторного использования</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : можно легко создавать пользовательские перехватчики и совместно использовать их между компонентами, что облегчает повторное использование логики с состоянием без сложных шаблонов, таких как компоненты более высокого порядка или реквизиты рендеринга.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Более чистый код</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : хуки приводят к более плоской иерархии компонентов и меньшему количеству шаблонов, что упрощает поддержку и понимание кода.</font></font></li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Использование хука useState</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Основы использования State:</font></font></strong></p>
<ul>
<li><p><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">— это хук, который позволяет добавлять состояние React к функциональным компонентам. Когда вы вызываете его, вы получаете пару: текущее значение состояния и функцию, позволяющую его обновить.</font></font></p>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Синтаксис</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Стандартный способ объявления состояния </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">— использование деструктуризации массива.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Пример</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></p>
<pre><code class="language-javascript">import React, { useState } from 'react';<font></font>
<font></font>
function Counter() {<font></font>
    const [count, setCount] = useState(0); // 0 is the initial state<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            &lt;p&gt;Count: {count}&lt;/p&gt;<font></font>
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
</li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Управление состоянием с помощью useState:</font></font></strong></p>
<ul>
<li><p><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">достаточно универсален, чтобы управлять любым типом состояния, который вам может понадобиться, включая строки, числа, массивы и объекты.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Управление объектами</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></p>
<pre><code class="language-javascript">function UserProfile() {<font></font>
    const [user, setUser] = useState({ name: 'John', age: 30 });<font></font>
<font></font>
    const updateAge = () =&gt; setUser({ ...user, age: user.age + 1 });<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            &lt;p&gt;Name: {user.name}&lt;/p&gt;<font></font>
            &lt;p&gt;Age: {user.age}&lt;/p&gt;<font></font>
            &lt;button onClick={updateAge}&gt;Increment Age&lt;/button&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Управление массивами</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></p>
<pre><code class="language-javascript">function TodoList() {<font></font>
    const [todos, setTodos] = useState(['Item 1', 'Item 2']);<font></font>
<font></font>
    const addTodo = todo =&gt; setTodos([...todos, todo]);<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            {todos.map((todo, index) =&gt; &lt;p key={index}&gt;{todo}&lt;/p&gt;)}<font></font>
            &lt;button onClick={() =&gt; addTodo('New Item')}&gt;Add Item&lt;/button&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
</li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Практическое упражнение: рефакторинг компонента класса</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Цель:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Рефакторинг компонента класса, который извлекает пользовательские данные, в функциональный компонент с помощью </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Шаги:</font></font></strong></p>
<ol>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Определите методы состояния и жизненного цикла в компоненте класса</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Просмотрите существующий компонент класса, чтобы определить, как </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">используются такие методы состояния и жизненного цикла.</font></font></p>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Преобразование в функциональный компонент с использованием useState</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';<font></font>
<font></font>
function UserProfile({ userID }) {<font></font>
    const [user, setUser] = useState(null);<font></font>
<font></font>
    useEffect(() =&gt; {<font></font>
        fetch(`https://api.example.com/user/${userID}`)<font></font>
            .then(response =&gt; response.json())<font></font>
            .then(data =&gt; setUser(data));<font></font>
    }, [userID]); // Dependency array includes userID to refetch when it changes<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            {user ? (<font></font>
                &lt;div&gt;<font></font>
                    &lt;h1&gt;{user.name}&lt;/h1&gt;<font></font>
                    &lt;p&gt;{user.email}&lt;/p&gt;<font></font>
                &lt;/div&gt;<font></font>
            ) : (<font></font>
                &lt;p&gt;Loading...&lt;/p&gt;<font></font>
            )}<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
</li>
<li><p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Проверьте функциональный компонент</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : убедитесь, что рефакторинг компонента работает должным образом, в частности, что он правильно извлекает и отображает пользовательские данные.</font></font></p>
</li>
</ol>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Это упражнение укрепит у учащихся понимание того, как использовать их </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">в реальных сценариях и перейти от компонентов класса к функциональным компонентам, используя мощь и простоту хуков.</font></font></p>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Обработка побочных эффектов с помощью useEffect</font></font></h3>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Понимание использования эффекта</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Хук </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">в React необходим для управления побочными эффектами в функциональных компонентах. Это мощная функция, которая заменяет несколько методов жизненного цикла, таких как </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">и </font></font><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from компоненты класса. Используя </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, разработчики могут организовать всю логику побочных эффектов в единый согласованный API, что упрощает поддержку и понимание кода.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Что такое побочные эффекты?</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Побочные эффекты — это операции, которые влияют на другие компоненты, не могут быть выполнены во время рендеринга и включают в себя:</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API-вызовы</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Подписки</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Изменение DOM вручную</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Таймеры</font></font></li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Синтаксис и использование</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Базовое использование:</font></font></strong>
<code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> позволяет выполнять побочные эффекты в вашем компоненте. Требуется два аргумента:</font></font></p>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Функция, содержащая код побочного эффекта.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Необязательный массив зависимостей, определяющий, когда эффект должен выполняться повторно.</font></font></li>
</ol>
<pre><code class="language-javascript">import { useEffect } from 'react';<font></font>
<font></font>
function ExampleComponent() {<font></font>
    useEffect(() =&gt; {<font></font>
        // Code here will run after every render by default<font></font>
        console.log('Component rendered or updated');<font></font>
<font></font>
        // Optional cleanup mechanism<font></font>
        return () =&gt; {<font></font>
            console.log('Cleanup on component unmount or before next re-render');<font></font>
        };<font></font>
    });<font></font>
}<font></font>
</code></pre>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Массив зависимостей.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Массив зависимостей является важнейшим аспектом </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">управления его выполнением:</font></font></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Dependency Array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : эффект запускается после каждого рендеринга.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Пустой массив зависимостей ( </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : эффект запускается один раз после первоначального рендеринга, имитируя </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Список зависимостей ( </font></font><code>[deps]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : эффект запускается после первоначального рендеринга и каждый раз при изменении любого значения в массиве зависимостей.</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Пример использования массива зависимостей:</font></font></strong></p>
<pre><code class="language-javascript">function UserComponent({ userID }) {<font></font>
    const [user, setUser] = useState(null);<font></font>
<font></font>
    useEffect(() =&gt; {<font></font>
        fetch(`https://api.example.com/users/${userID}`)<font></font>
            .then(response =&gt; response.json())<font></font>
            .then(userData =&gt; setUser(userData));<font></font>
<font></font>
        return () =&gt; {<font></font>
            // Cleanup code here<font></font>
        };<font></font>
    }, [userID]); // Effect re-runs only if userID changes<font></font>
}<font></font>
</code></pre>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Сложные эффекты и очистка</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Возврат функции очистки:</font></font></strong>
<code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> опционально может возвращать функцию, которая очищает после эффекта. Это полезно для:</font></font></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Отписка от подписок для предотвращения утечек памяти.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Очистка таймеров или отмена текущих сетевых запросов.</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Пример с очисткой:</font></font></strong></p>
<pre><code class="language-javascript">function TimerComponent() {<font></font>
    useEffect(() =&gt; {<font></font>
        const timerID = setInterval(() =&gt; {<font></font>
            console.log('Timer tick');<font></font>
        }, 1000);<font></font>
<font></font>
        return () =&gt; {<font></font>
            clearInterval(timerID);<font></font>
        };<font></font>
    }, []); // Empty dependency array means this runs only on mount<font></font>
}<font></font>
</code></pre>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Практические упражнения</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Упражнение 1. Эффект выборки данных</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Реализуйте компонент, который извлекает пользовательские данные из API при его монтировании и обновляет данные при каждом изменении данного идентификатора пользователя.</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Упражнение 2: Эффект интервального таймера</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Создайте </font></font><code>Clock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">компонент, который использует интервал для обновления текущего времени каждую секунду.</font></font></li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Реализация компонента часов:</font></font></strong></p>
<pre><code class="language-javascript">function Clock() {<font></font>
    const [currentTime, setCurrentTime] = useState(new Date());<font></font>
<font></font>
    useEffect(() =&gt; {<font></font>
        const timerId = setInterval(() =&gt; {<font></font>
            setCurrentTime(new Date());<font></font>
        }, 1000);<font></font>
<font></font>
        return () =&gt; {<font></font>
            clearInterval(timerId);<font></font>
        };<font></font>
    }, []); // Empty array ensures this runs only once<font></font>
<font></font>
    return (<font></font>
        &lt;div&gt;<font></font>
            &lt;h1&gt;Current Time&lt;/h1&gt;<font></font>
            &lt;p&gt;{currentTime.toLocaleTimeString()}&lt;/p&gt;<font></font>
        &lt;/div&gt;<font></font>
    );<font></font>
}<font></font>
</code></pre>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Эти упражнения предназначены для того, чтобы дать практический опыт и </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">продемонстрировать, как его можно использовать для эффективного управления побочными эффектами в функциональных компонентах. В упражнениях освещаются как базовые, так и расширенные возможности использования, включая критическую роль функции очистки во избежание утечек ресурсов.</font></font></p>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Подведение итогов и вопросы и ответы</font></font></h3>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Завершая сегодняшнее подробное исследование методов жизненного цикла React в компонентах классов и революционных хуков в функциональных компонентах, давайте резюмируем ключевые понятия и подготовимся к сессии вопросов и ответов, чтобы прояснить все оставшиеся неопределенности.</font></font></p>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Обзор и резюме</font></font></h4>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Методы жизненного цикла в компонентах класса:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Обзор:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Мы обсудили критически важные методы жизненного цикла </font></font><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">— </font></font><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, и </font></font><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Эти методы позволяют отслеживать определенные моменты в жизни компонента: когда он добавляется в DOM, обновляется и удаляется из DOM соответственно.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Приложения:</font></font></strong> <ul>
<li><code>componentDidMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">идеально подходит для настройки подписок, получения данных и других задач настройки, которые следует запускать только один раз после первоначального рендеринга.</font></font></li>
<li><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">позволяет реагировать на изменения реквизита или состояния, что делает его полезным для корректировки обновленных данных или повторной выборки данных при изменении определенных условий.</font></font></li>
<li><code>componentWillUnmount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">имеет решающее значение для таких действий по очистке, как аннулирование таймеров, отмена сетевых запросов или очистка подписок для предотвращения утечек памяти.</font></font></li>
</ul>
</li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Введение в хуки:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Трансформация функциональных компонентов.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Хуки представляют собой значительное достижение в React, предоставляя функциональным компонентам возможности, которые когда-то были возможны только в компонентах классов.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useState и useEffect:</font></font></strong><ul>
<li><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">предлагает способ добавления логики с отслеживанием состояния к функциональным компонентам, позволяя им поддерживать внутреннее состояние с течением времени.</font></font></li>
<li><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">служит унифицированным способом обработки побочных эффектов в функциональных компонентах, эффективно заменяя несколько методов жизненного цикла и предлагая более точный контроль над тем, когда возникают побочные эффекты и как они устраняются.</font></font></li>
</ul>
</li>
</ul>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Практические применения и упражнения:</font></font></strong></p>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Мы применили эти концепции с помощью практических упражнений, таких как преобразование компонента класса, извлекающего данные, в функциональный компонент с помощью </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">и </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Эти упражнения не только закрепили материал, но и продемонстрировали практические преимущества хуков, такие как сокращение шаблонов и улучшение организации кода.</font></font></li>
</ul>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Сессия вопросов и ответов</font></font></h4>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Теперь давайте перейдем к сеансу вопросов и ответов. Это прекрасная возможность для вас задать вопросы по любому аспекту сегодняшнего материала. Если вам нужны разъяснения по деталям методов жизненного цикла, механике конкретных хуков или советы о том, как применить эти концепции к реальным проблемам, не стесняйтесь задавать свои вопросы.</font></font></p>
<p><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Возможные темы для обсуждения:</font></font></strong></p>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Различия в вариантах использования:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> когда вы можете предпочесть компоненты класса функциональным компонентам, особенно с учетом хуков?</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Оптимизация производительности с помощью хуков:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> как предотвратить ненужные рендеринги при использовании </font></font><code>useState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">и </font></font><code>useEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Расширенные шаблоны перехватчиков:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> существуют ли более сложные сценарии, в которых было бы полезно объединить несколько перехватчиков?</font></font></li>
</ul>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Не стесняйтесь делиться своим опытом, любыми конкретными проблемами, с которыми вы столкнулись, или тем, как вы планируете применять полученные знания в своих проектах. Это обсуждение может помочь укрепить ваше понимание и вдохновить на новые идеи по использованию мощных функций React в вашей работе по разработке.</font></font></p>
		</div>

		









		<script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js" integrity="sha512-LhccdVNGe2QMEfI3x4DVV3ckMRe36TfydKss6mJpdHjNFiV07dFpS2xzeZedptKZrwxfICJpez09iNioiSZ3hA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
		<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/javascript.min.js"></script>

		<script>
			let currentLanguage = 'en';
			const copiedTexts = {
				en: 'Copied to clipboard!',
				hy: 'Պատճենվել է սեղմատախտակում:',
				ru: 'Скопировано в буфер обмена!'
			}

			function copyCode(index) {
				const code = document.getElementById('code-block-' + index).innerText;
				const copied = document.getElementById('copied-' + index);
			
				navigator.clipboard.writeText(code).then(() => {
					copied.innerText = copiedTexts[currentLanguage];
				});

				setTimeout(() => {
					copied.innerText = '';
				}, 3000);
			}

			// Initialize Highlight.js after the document is fully loaded
			document.addEventListener('DOMContentLoaded', (event) => {
				hljs.highlightAll();
			});

			let en = document.getElementById('en');
			let hy = document.getElementById('hy');
			let ru = document.getElementById('ru');
			let html_en = document.getElementById('html_en');
			let html_hy = document.getElementById('html_hy');
			let html_ru = document.getElementById('html_ru');
			
			en.addEventListener('click', function(){
				html_en.style.display = 'block';
				html_hy.style.display = 'none';
				html_ru.style.display = 'none';
				
				en.style.display = 'none';
				hy.style.display = 'inline';
				ru.style.display = 'inline';
				
				document.getElementsByTagName('title')[0].innerText = html_en.getElementsByTagName('h2')[0].innerText
				currentLanguage = 'en';
			});
			
			hy.addEventListener('click', function(){
				html_en.style.display = 'none';
				html_hy.style.display = 'block';
				html_ru.style.display = 'none';
				
				en.style.display = 'inline';
				hy.style.display = 'none';
				ru.style.display = 'inline';
				
				document.getElementsByTagName('title')[0].innerText = html_hy.getElementsByTagName('h2')[0].innerText
				
				currentLanguage = 'hy';
			});
			
			ru.addEventListener('click', function(){
				html_en.style.display = 'none';
				html_hy.style.display = 'none';
				html_ru.style.display = 'block';
				
				en.style.display = 'inline';
				hy.style.display = 'inline';
				ru.style.display = 'none';
				
				document.getElementsByTagName('title')[0].innerText = html_ru.getElementsByTagName('h2')[0].innerText
				currentLanguage = 'ru';
			});

			let presLang = {
				en: document.querySelectorAll('#html_en pre'), 
				hy: document.querySelectorAll('#html_hy pre'), 
				ru: document.querySelectorAll('#html_ru pre')
			};
			
			let key = 1;
			
			for(let lang in presLang){
				let pres = presLang[lang];

				pres.forEach(function(pre){
					let copyText = lang == 'hy' ? 'Պատճենել' : lang == 'ru' ? 'Копировать' : 'Copy';
					let card = document.createElement('div');
					card.className = 'card bg-dark text-white';
					pre.firstChild.id = 'code-block-' + key
					let cardHtml = `
						<div class="card-header">
							<button class="btn btn-primary" onclick="copyCode(${key})">${copyText}</button>
							<span id="copied-${key}" class="float-end"></span>
						</div>
						<div class="p-0">
							<pre>${pre.innerHTML}</pre>
						</div>
					`
					card.innerHTML = cardHtml;
					
					pre.parentNode.replaceChild(card, pre);
					key++;
				});
			}
			
		</script>
	</body>
</html>